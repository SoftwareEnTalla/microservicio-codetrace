/*
 * Copyright (c) 2026 SoftwarEnTalla
 * Licencia: MIT
 * Contacto: softwarentalla@gmail.com
 * CEOs: 
 *       Persy Morell Guerra      Email: pmorellpersi@gmail.com  Phone : +53-5336-4654 Linkedin: https://www.linkedin.com/in/persy-morell-guerra-288943357/
 *       Dailyn García Domínguez  Email: dailyngd@gmail.com      Phone : +53-5432-0312 Linkedin: https://www.linkedin.com/in/dailyn-dominguez-3150799b/
 *
 * CTO: Persy Morell Guerra
 * COO: Dailyn García Domínguez and Persy Morell Guerra
 * CFO: Dailyn García Domínguez and Persy Morell Guerra
 *
 * Repositories: 
 *               https://github.com/SoftwareEnTalla 
 *
 *               https://github.com/apokaliptolesamale?tab=repositories
 *
 *
 * Social Networks:
 *
 *              https://x.com/SoftwarEnTalla
 *
 *              https://www.facebook.com/profile.php?id=61572625716568
 *
 *              https://www.instagram.com/softwarentalla/
 *              
 *
 *
 */


import { Resolver, Query, Mutation, Args } from "@nestjs/graphql";

//Definición de entidades
import { codetrace } from "../entities/codetrace.entity";

//Definición de comandos
import {
  CreatecodetraceCommand,
  UpdatecodetraceCommand,
  DeletecodetraceCommand,
} from "../commands/exporting.command";

import { CommandBus } from "@nestjs/cqrs";
import { codetraceQueryService } from "../services/codetracequery.service";


import { codetraceResponse, codetracesResponse } from "../types/codetrace.types";
import { FindManyOptions } from "typeorm";
import { PaginationArgs } from "src/common/dto/args/pagination.args";
import { fromObject } from "src/utils/functions";

//Logger
import { LogExecutionTime } from "src/common/logger/loggers.functions";
import { LoggerClient } from "src/common/logger/logger.client";
import { logger } from '@core/logs/logger';

import { v4 as uuidv4 } from "uuid";

//Definición de tdos
import { UpdatecodetraceDto, 
CreateOrUpdatecodetraceDto, 
codetraceValueInput, 
codetraceDto, 
CreatecodetraceDto } from "../dtos/all-dto";
 

//@UseGuards(JwtGraphQlAuthGuard)
@Resolver(() => codetrace)
export class codetraceResolver {

   //Constructor del resolver de codetrace
  constructor(
    private readonly service: codetraceQueryService,
    private readonly commandBus: CommandBus
  ) {}

  @LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  // Mutaciones
  @Mutation(() => codetraceResponse<codetrace>)
  async createcodetrace(
    @Args("input", { type: () => CreatecodetraceDto }) input: CreatecodetraceDto
  ): Promise<codetraceResponse<codetrace>> {
    return this.commandBus.execute(new CreatecodetraceCommand(input));
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Mutation(() => codetraceResponse<codetrace>)
  async updatecodetrace(
    @Args("id", { type: () => String }) id: string,
    @Args("input") input: UpdatecodetraceDto
  ): Promise<codetraceResponse<codetrace>> {
    const payLoad = input;
    return this.commandBus.execute(
      new UpdatecodetraceCommand(payLoad, {
        instance: payLoad,
        metadata: {
          initiatedBy: payLoad.createdBy || 'system',
          correlationId: payLoad.id,
        },
      })
    );
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Mutation(() => codetraceResponse<codetrace>)
  async createOrUpdatecodetrace(
    @Args("data", { type: () => CreateOrUpdatecodetraceDto })
    data: CreateOrUpdatecodetraceDto
  ): Promise<codetraceResponse<codetrace>> {
    if (data.id) {
      const existingcodetrace = await this.service.findById(data.id);
      if (existingcodetrace) {
        return this.commandBus.execute(
          new UpdatecodetraceCommand(data, {
            instance: data,
            metadata: {
              initiatedBy:
                (data.input as CreatecodetraceDto | UpdatecodetraceDto).createdBy ||
                'system',
              correlationId: data.id,
            },
          })
        );
      }
    }
    return this.commandBus.execute(
      new CreatecodetraceCommand(data, {
        instance: data,
        metadata: {
          initiatedBy:
            (data.input as CreatecodetraceDto | UpdatecodetraceDto).createdBy ||
            'system',
          correlationId: data.id || uuidv4(),
        },
      })
    );
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Mutation(() => Boolean)
  async deletecodetrace(
    @Args("id", { type: () => String }) id: string
  ): Promise<boolean> {
    return this.commandBus.execute(new DeletecodetraceCommand(id));
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  // Queries
  @Query(() => codetracesResponse<codetrace>)
  async codetraces(
    options?: FindManyOptions<codetrace>,
    paginationArgs?: PaginationArgs
  ): Promise<codetracesResponse<codetrace>> {
    return this.service.findAll(options, paginationArgs);
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => codetracesResponse<codetrace>)
  async codetrace(
    @Args("id", { type: () => String }) id: string
  ): Promise<codetraceResponse<codetrace>> {
    return this.service.findById(id);
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => codetracesResponse<codetrace>)
  async codetracesByField(
    @Args("field", { type: () => String }) field: string,
    @Args("value", { type: () => codetraceValueInput }) value: codetraceValueInput,
    @Args("page", { type: () => Number, defaultValue: 1 }) page: number,
    @Args("limit", { type: () => Number, defaultValue: 10 }) limit: number
  ): Promise<codetracesResponse<codetrace>> {
    return this.service.findByField(
      field,
      value,
      fromObject.call(PaginationArgs, { page: page, limit: limit })
    );
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => codetracesResponse<codetrace>)
  async codetracesWithPagination(
    @Args("page", { type: () => Number, defaultValue: 1 }) page: number,
    @Args("limit", { type: () => Number, defaultValue: 10 }) limit: number
  ): Promise<codetracesResponse<codetrace>> {
    const paginationArgs = fromObject.call(PaginationArgs, {
      page: page,
      limit: limit,
    });
    return this.service.findWithPagination({}, paginationArgs);
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => Number)
  async totalcodetraces(): Promise<number> {
    return this.service.count();
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => codetracesResponse<codetrace>)
  async searchcodetraces(
    @Args("where", { type: () => codetraceDto, nullable: false })
    where: Record<string, any>
  ): Promise<codetracesResponse<codetrace>> {
    const codetraces = await this.service.findAndCount(where);
    return codetraces;
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => codetraceResponse<codetrace>, { nullable: true })
  async findOnecodetrace(
    @Args("where", { type: () => codetraceDto, nullable: false })
    where: Record<string, any>
  ): Promise<codetraceResponse<codetrace>> {
    return this.service.findOne(where);
  }


@LogExecutionTime({
    layer: 'resolver',
    callback: async (logData, client) => {
      // Puedes usar el cliente proporcionado o ignorarlo y usar otro
      try{
        logger.info('Información del cliente y datos a enviar:',[logData,client]);
        return await client.send(logData);
      }
      catch(error){
        logger.info('Ha ocurrido un error al enviar la traza de log: ', logData);
        logger.info('ERROR-LOG: ', error);
        throw error;
      }
    },
    client: LoggerClient.getInstance()
      .registerClient(codetraceResolver.name)

      .get(codetraceResolver.name),
    })
  @Query(() => codetraceResponse<codetrace>)
  async findOnecodetraceOrFail(
    @Args("where", { type: () => codetraceDto, nullable: false })
    where: Record<string, any>
  ): Promise<codetraceResponse<codetrace> | Error> {
    return this.service.findOneOrFail(where);
  }
}

